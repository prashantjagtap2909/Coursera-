Progamming Assignment 3

Problem 2. Rapid Sorting of Arrays with Bounded Number of Elements.

def swap(a, i, j):
    assert 0 <= i < len(a), f'accessing index {i} beyond end of array {len(a)}'
    assert 0 <= j < len(a), f'accessing index {j} beyond end of array {len(a)}'
    a[i], a[j] = a[j], a[i]

def simplePartition(a, pivot):
    ## To do: partition the array a according to pivot.
    # Your array must be partitioned into two regions - <= pivot followed by elements > pivot
    ## If an element at the beginning of the array is already <= pivot in the beginning of the array, it should not
    ## be moved by the algorithm.
    # your code here
    #student name Prashant jagtap
    # I always hate swap. no swap here
    # I also hate function based on side-effect. Very unintuitive 
    left_partition, right_partition = [], []
    for elt in a:
        if elt <= pivot:
            left_partition.append(elt)
        else:
            right_partition.append(elt)
    # ugly code to affect "a" (bring in side-effect)
    for i, elt in enumerate(left_partition + right_partition):
        a[i] = elt
#     return left_partition + right_partition
            
    
            
def boundedSort(a, k):
    for j in range(1, k):
        simplePartition(a, j)
        
        
********************************************************************************************************************

